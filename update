const crypto = require('crypto');
const cbor = require('cbor');
const base64url = require('base64url');
const fs = require('fs/promises');

/**
 * Reads from input.txt, signs the challenge, and writes to signedInput.txt
 */
async function signChallenge() {
  try {
    // Read input file
    const input = JSON.parse(await fs.readFile('input.txt', 'utf8'));
    const registrationId = input.registrationId;
    const publicKeyCredentialCreationOptions = JSON.parse(input.publicKeyCredentialCreationOptions);
    const { challenge, rp, user } = publicKeyCredentialCreationOptions.publicKey;
    
    // Generate key pair
    const keyPair = crypto.generateKeyPairSync('ec', {
      namedCurve: 'prime256v1',
      publicKeyEncoding: { type: 'spki', format: 'der' },
      privateKeyEncoding: { type: 'pkcs8', format: 'pem' },
    });
    
    // Set origin based on rp.id
    const origin = rp.id === "localhost" 
      ? "http://localhost:3000"
      : `https://${rp.id}`;
    
    // Create client data JSON
    const clientDataJSON = Buffer.from(JSON.stringify({
      type: 'webauthn.create',
      challenge: challenge,
      origin: origin,
      crossOrigin: false,
    }));
    
    // Generate authenticator data
    const rpIdHash = crypto.createHash('sha256').update(rp.id).digest();
    const flagsBuf = Buffer.from([0x41]);
    const signCountBuf = Buffer.alloc(4);
    const aaguid = Buffer.alloc(16);
    const credId = crypto.randomBytes(16);
    const credIdLenBuf = Buffer.alloc(2);
    credIdLenBuf.writeUInt16BE(credId.length, 0);
    
    // Extract and encode public key
    const publicKeyCoords = extractPublicKeyCoords(keyPair.publicKey);
    const cosePublicKey = new Map([
      [1, 2],
      [3, -7],
      [-1, 1],
      [-2, publicKeyCoords.x],
      [-3, publicKeyCoords.y],
    ]);
    const credentialPublicKey = cbor.encodeCanonical(cosePublicKey);
    
    // Combine all parts into authenticator data
    const authenticatorData = Buffer.concat([
      rpIdHash,
      flagsBuf,
      signCountBuf,
      aaguid,
      credIdLenBuf,
      credId,
      credentialPublicKey,
    ]);
    
    // Create attestation object
    const attestationObject = cbor.encodeCanonical({
      fmt: 'none',
      attStmt: {},
      authData: authenticatorData,
    });
    
    // Format final credential
    const credential = {
      id: base64url(credId),
      rawId: base64url(credId),
      response: {
        clientDataJSON: base64url(clientDataJSON),
        attestationObject: base64url(attestationObject),
      },
      type: 'public-key',
      clientExtensionResults: {},
      authenticatorAttachment: 'platform',
    };
    
    // Prepare output
    const finalOutput = {
      registrationId,
      publicKeyCredentialString: JSON.stringify(credential),
    };
    
    // Write to signedInput.txt
    await fs.writeFile('signedInput.txt', JSON.stringify(finalOutput, null, 2));
    console.log('Credential signed and saved to "signedInput.txt"');
  } catch (error) {
    console.error('Error signing challenge:', error);
  }
}

/**
 * Extracts public key coordinates from DER encoded key
 */
function extractPublicKeyCoords(spkiDer) {
  let offset = spkiDer.length - 65;
  while (offset >= 0) {
    if (spkiDer[offset] === 0x04 && offset + 65 <= spkiDer.length) {
      const coords = spkiDer.slice(offset + 1, offset + 65);
      return {
        x: coords.slice(0, 32),
        y: coords.slice(32),
      };
    }
    offset--;
  }
  throw new Error('Failed to extract public key coordinates');
}

// Run the function
signChallenge();
